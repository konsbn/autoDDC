import json
import os
import mechanicalsoup
from scraper import scrapertools
from itertools import chain
from collections import OrderedDict

browser = mechanicalsoup.StatefulBrowser()
 

def _categorylist(ddc):
    '''Just Gets The Broad classes upto the tenth place given broad DDC Class
       eg:

       DDC 500 will fetch everything till 599'''

    # Goes to the Summary Page of OCLC
    browser.open('https://www.oclc.org/en/dewey/resources/summaries.html')
    page = browser.get_current_page()
    cat = page.find('a', {'name': str(ddc)}).find_next(
        'tr').contents  # Finds the Table of DDC and writes it to cat
    while '\n' in cat:  # Basic Cleanup
        cat.remove('\n')
    cat = [i.string for i in (
        cat[0].contents + cat[1].contents) if i.string is not None]
    return(cat)


def GetAllCategory():
    '''
    Gets all the DDC Categories from 000 to 999
    Output : OrderedDict[DDC] = 'Genre'
    '''
    DDC_Categories = ['000', '100', '200', '300',
                      '400', '500', '600', '700', '800', '900']
    # Fetch DDC Genres For all the Broad Categories and Chain
    # together in one list. String cleanup is performed to strip
    # whitespaces. Should have done it more explicitly
    CatList = [i.strip() for i in list(chain.from_iterable(
        map(_categorylist, DDC_Categories))) if i != ' ']
    # CatList -> Complete_DDC_Categories[DDC] = Genre
    Complete_DDC_Categories = OrderedDict()
    for i in CatList:
        ddc_class, genre = i.split(' ')[0], ' '.join(i.split(' ')[1:])
        Complete_DDC_Categories.update(OrderedDict([(ddc_class, genre)]))
    return(Complete_DDC_Categories)


def store_categories(filename='ddc_summary.json'):
    with open(filename, 'w') as outfile:
        json.dump(GetAllCategory(), outfile)


def read_categories(filename='ddc_summary.json'):
    return json.load(open('ddc_summary.json'), object_pairs_hook=OrderedDict)


def check_if_exists(path='./'):
    return os.path.isfile(path+'ddc_summary.json')


def get_summaries():
    if check_if_exists():
        return read_categories()
    else:
        store_categories()
        return read_categories()


class ISBNError(Exception):
    '''
    Raises an exception when ISBN is invalid
    '''

    def __init__(self, expression, message):
        self.expression = expression
        self.message = message


def isddc(ddc):
    try:
        float(ddc)
        return True
    except ValueError:
        return False


def isValid(isbn):
    '''
    Returns : True is Valid ISBN else False
    Eg:
    >>> isValid(9780231175968)
    True
    >>> isValid(123)
    Traceback (most recent call last):
        ...
    ISBNError: ('123', 'ISBN is Invalid')
    '''

    isbn = list(str(isbn))  # We need to iterate over this!
    if len(isbn) == 13:
        isbn = [int(j)*1 if (int(i)+1) % 2 != 0 else int(j)
                * 3 for i, j in enumerate(isbn)]
        if sum(isbn) % 10 == 0:
            return
        else:
            raise ISBNError(''.join(isbn), 'ISBN is Invalid')
    else:
        raise ISBNError(''.join(isbn), 'ISBN is Invalid')


class AutoDDC:
    def __init__(self):
        '''
        Initializes the Browser Class
        '''
        self.browser = mechanicalsoup.StatefulBrowser()
        self.getter = scrapertools()
        self.summaries = cat.get_summaries()

    def find_in_url(self, url):
        '''
        Finds the DDC in the current page or returns the list of links to follow
        '''
        self.getter.page_getter(url)
        try:
            self.cat = self.getter.table_getter('classSummaryData')
            # if self.cat is not None:
            return self.cat
        except AttributeError:
            self.links = self.getter.table_getter('results-table')
            return self.links

    def ddc_urlwrapper(self, isbn):
        '''
        Gets the Dewey Decimal Classification given isbn
        Input
        >>> isbn
        Output
        DDC
        '''
        url = "http://classify.oclc.org"
        url1 = url + "/classify2/ClassifyDemo?search-standnum-txt=" + \
            str(isbn) + "&startRec=0"
        return url1

    def pretty_ddc(self):
        try:
            for i in self.cat.values():
                if i['DDC:'] == 'Most Frequent':
                    if isddc(i['Class Number']):
                        return i['Class Number']
        except AttributeError:

            self.find_in_url(self.links[0]['Link'])
            for i in self.cat.values():
                if i['DDC:'] == 'Most Frequent':
                    if isddc(i['Class Number']):
                        return i['Class Number']

